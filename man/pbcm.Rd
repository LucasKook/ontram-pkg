% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/pbcm-k_ontram.R
\name{pbcm}
\alias{pbcm}
\title{Parametric Bootstrap Cross-fitting Method}
\usage{
pbcm(
  m,
  x,
  y,
  n_split = 5,
  n_npBoot = 1,
  n_sim = 1,
  split = c(0.9, 0.1, 0.1),
  optimizer = optimizer_adam(learning_rate = 0.01),
  batch_size = 7,
  epochs = rep(10, length(m)),
  loss = k_ontram_loss(ncol(y)),
  filepath = "weights_best.h5",
  callback_model_ckpts_args = list(monitor = "val_loss", save_best_only = TRUE,
    save_weights_only = TRUE, mode = "min"),
  img_augmentation = FALSE,
  aug_params = list(horizontal_flip = FALSE, vertical_flip = FALSE, zoom_range = 0.1,
    rotation_range = 5, shear_range = 0, width_shift_range = 0.1, height_shift_range =
    0.1, fill_mode = "nearest"),
  seed = NULL
)
}
\arguments{
\item{m}{list of models (either of class \code{\link{k_ontram}} or \code{\link[tram]{tram}}).}

\item{x}{list containing data for each model separately (as list).}

\item{y}{response variable (one-hot encoded).}

\item{n_split}{number of random splits.}

\item{n_npBoot}{number of non-parametric bootstrap samples (after each random split).}

\item{n_sim}{number of simulated response variables.}

\item{split}{proportion of data used for training, testing and validating the models. The proportion for validating the models is calculated with respect to the training set (e.g. 10\% of 90\% of all data).}

\item{epochs}{vector containing number of epochs for each model.}

\item{loss}{loss function.}

\item{filepath}{path where model checkpoints are saved (get removed after training).}

\item{callback_model_ckpts_args}{list of arguments used as input for function \code{\link[keras]{callback_model_checkpoint}}.}

\item{img_augmentation}{logical. Whether to augment training data.}

\item{aug_params}{list of arguments used as input for function \code{\link[keras]{image_data_generator}}.}
}
\description{
Parametric Bootstrap Cross-fitting Method
}
\examples{
set.seed(2021)
library(ggplot2)
data(wine, package = "ordinal")
wine$noise <- rnorm(nrow(wine))
y <- model.matrix(~ 0 + rating, data = wine)
x <- ontram:::.rm_int(model.matrix(rating ~ temp + contact, data = wine))
im <- ontram:::.rm_int(model.matrix(rating ~ noise, data = wine))
int <- matrix(1, nrow = nrow(wine))
loss <- k_ontram_loss(ncol(y))
mbl <- k_mod_baseline(ncol(y))
msh <- mod_shift(ncol(x))
mim <- keras_model_sequential(name = "complex_shift") \%>\%
   layer_dense(input_shape = 1L, units = 8, activation = "relu") \%>\%
   layer_dense(units = 1, use_bias = FALSE, activation = "linear")
mo1 <- k_ontram(mbl, msh)
mo2 <- k_ontram(mbl, list(msh, mim))
m <- list(mo1, mo2)
x <- list(list(int, x), list(int, x, im))
pbcm_out <- pbcm(m, x, y, n_split = 3)
plot(pbcm_out)
plot(pbcm_out, obs_av = TRUE)
}
